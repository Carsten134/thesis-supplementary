---
title: "Funktionale Formen von Tn und Tn_star"
author: "Carsten Stahl"
date: "2025-04-07"
output: pdf_document
---

```{r setup, include=FALSE}
library(rspsp)
knitr::opts_chunk$set(echo = TRUE)
```

## Einführung
Nachdem wir nun die riemann approximation und die Spektraldichte-Schätzung validiert haben, würde ich mich jetzt mal den Teststatistiken $T_n$ und $T_n^*$ unter $H_0$ widmen.

Gegeben seien also Daten unter $H_0$:
```{r simulation}
set.seed(123)
K <- matrix(.7, 3, 3)
K[2,2] <- 1

x <- gridMA(50, 50, K)
y <- gridMA(50, 50, K)
```

Unter diesen Daten sind die können wir $h$ tunen, sodass die geschätzten Spektraldichten möglichst nahe an der wahren Spektraldichte sind (hier nur visuel):

```{r pressure, echo=FALSE}
par(mfrow = c(1,3))
plot.spectral_density(f_true_MA(K))
h <- .92
plot.I_smooth(I_smooth(I(x), hr = h, hc = h))
plot.I_smooth(I_smooth(I(y), hr = h, hc = h))
```
Die Teststatistik $T_n$ integriet die funktion:

```{r Tn}
I_x <- I(x)
I_y <- I(y)
I_tilde <- .5*(I_x + I_y)

I_x_s <- I_smooth(I_x - I_tilde, hr = h, hc = h)
I_y_s <- I_smooth(I_y - I_tilde, hr = h, hc = h)
Tn_f <- function(x, y) I_x_s(x,y)^2 + I_y_s(x,y)^2
class(Tn_f) <- c("I_smooth", "grid_function")

plot.I_smooth(Tn_f)
```

Und die funktion über die $T_n^*$ integriert:

```{r Tn_star}
N <- nrow(x)
M <- ncol(x)
h <- 1
perm <- matrix(as.numeric(runif(N*M) > .5), ncol = N)
perm_n <- matrix(as.numeric(perm != 1), ncol = N)
I_x_rand <- I(x)*perm + I(y)*perm_n
I_y_rand <- I(x)*perm_n + I(y)*perm

I_x_r_s <- I_smooth(I_x_rand - I_tilde, hr = h, hc = h)
I_y_r_s <- I_smooth(I_y_rand - I_tilde, hr = h, hc = h)

Tn_star_f <- function(x, y) I_x_r_s(x, y)^2 + I_y_r_s(x, y)^2
class(Tn_star_f) <- c("I_smooth", "grid_function")

plot.I_smooth(Tn_star_f)
```

\begin{itemize}
  \item Also es ist faktisch so, dass die Funktion von $T_n^*$ unter $H_0$ sehr viel höhere Gipfel hat, als die von $T_n$.
  \item Das könnte so sein, weil unter zwei dimensionalen Periodogrammen die Schätzungen für Frequenzpaare nicht mehr asympotisch unabhängig sind (oder einfach langsamer unabhängig werden).
  \item Problematisch, weil mann auf der einen Seite Unabhängigkeit erreichen will, aber auf der anderen Seite die Riemann approximation stabil halten will.
  \item Wir testen diese Hypothese, mal indem wir einen zeilenweisen MA simulieren.
\end{itemize}


```{r}
K_row <- matrix(0, 3, 3)
K_row[,2] <- .7
K_row[2,2] <- 1

x <- gridMA(50, 50, K_row)
y <- gridMA(50, 50, K_row)

plot_Tn_and_Tn_star <- function(x,y, smooth = 1.5) {
  I_x <- I(x)
  I_y <- I(y)
  I_tilde <- .5*(I_x + I_y)
  
  I_x_s <- I_smooth(I_x - I_tilde, hr = smooth, hc = smooth)
  I_y_s <- I_smooth(I_y - I_tilde, hr = smooth, hc = smooth)
  Tn_f <- function(x, y) I_x_s(x,y)^2 + I_y_s(x,y)^2
  class(Tn_f) <- c("I_smooth", "grid_function")
  N <- nrow(x)
  M <- ncol(x)
  
  perm <- matrix(as.numeric(runif(N*M) > .5), ncol = N)
  perm_n <- matrix(as.numeric(perm != 1), ncol = N)
  I_x_rand <- I(x)*perm + I(y)*perm_n
  I_y_rand <- I(x)*perm_n + I(y)*perm
  
  I_x_r_s <- I_smooth(I_x_rand - I_tilde, hr = smooth, hc = smooth)
  I_y_r_s <- I_smooth(I_y_rand - I_tilde, hr = smooth, hc = smooth)
  
  Tn_star_f <- function(x, y) I_x_r_s(x, y)^2 + I_y_r_s(x, y)^2
  class(Tn_star_f) <- c("I_smooth", "grid_function")
  
  par(mfrow = c(1,2))  
  plot.I_smooth(Tn_f)
  plot.I_smooth(Tn_star_f)
}
```


Erstmal schauen wir uns die Spektraldichten an:

```{r}
par(mfrow = c(1,3))
plot.spectral_density(f_true_MA(K_row))
h <- 1
plot.I_smooth(I_smooth(I(x), hr = h, hc = h))
plot.I_smooth(I_smooth(I(y), hr = h, hc = h))

```
```{r}
plot_Tn_and_Tn_star(x, y, smooth = 3)
```


```{r}
K_col <- matrix(0, 3, 3)
K_col[2,] <- .7
K_col[2,2] <- 1
x <- gridMA(50, 50, K_row)
y <- gridMA(50, 50, K_row)

phi_n_star(x,y, 50, .05, hr = 3, hc = 3)
```

